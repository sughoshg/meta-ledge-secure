#!/bin/sh

# Idea is:
# - Storage already encrypted:
# 1. watch for ROOT_UUID in all blk devices. If exist decrypt, mount and boot.
# - Storage not encrypted (first boot):
# 1. watch for root=UUID=<> in /proc/cmdline
# 2. backup rootfs files to tmpfs
# 3. encrypts this device with password 'ledge'
# 4. add tpm luks signature for crypto device
# 5. mount and boot

# qemu debug
# efidebug boot add -b 1 BootLedge virtio 0:1 efi/boot/bootaa64.efi -i virtio 0:1 ledge-initramfs.rootfs.cpio.gz -s 'console=ttyAMA0,115200 root=UUID=6091b3a4-ce08-3020-93a6-f755a22ef03b rootwait panic=60 rdinit=/bin/sh'


ARG_MNT_TARGET=$1
ARG_ROOT=$2

atexit () {
  [ "$RNGD_PID" ] && kill $RNGD_PID
  [ "$DBUS_PID" ] && kill $DBUS_PID
  [ "$ABRMD_PID" ] && kill $ABRMD_PID
}

trap atexit EXIT

/usr/sbin/rngd -f&
RNGD_PID=$!
modprobe tpm_tis
modprobe blk_dev_dm
modprobe dm_crypt

rpmb_cid () {
  for f in /sys/class/mmc_host/mmc*/mmc*\:*/cid; do
    # POSIX shells don't expand globbing patterns that match no file
    [ -e $f ] || return
    devtype=$(echo $f | sed 's/cid/type/')
    [ ! -e $devtype ] && continue
    [ "$(cat $devtype)" != "MMC" ] && continue
    [ "$CID" ] && { echo $0: WARNING: multiple eMMC devices found! >&2; return ; }
    CID=$(cat $f)
  done
  [ "$CID" ] && echo --rpmb-cid $CID
}

tee-supplicant -d $(rpmb_cid)
modprobe tpm_ftpm_tee

# encrypted luks uuid
ROOT_UUID="310919c2-aec9-4641-b3d2-111111111111"

cryptfs_create_enc_rootfs() {
	uuid=$(echo $ARG_ROOT | sed s/UUID=//)
	ROOT_BLK=$(blkid | grep ${uuid} | cut -d":" -f 1)
	if [ -z "${ROOT_BLK}" ]; then
		echo "No rootfs with label rootfs check you /proc/cmdline:"
		cat /proc/cmdline
		/sbin/reboot
		return 1
	fi

	echo ""
	echo "!!!! Warning: erase and encryption is in progress.!!!!"
	echo "!!!! Do not reset/power off your machine until this process compile.!!!!"
	echo ""

	mkdir -p /run/dbus
	dbus-daemon --system
	DBUS_PID=$!
	tpm2-abrmd --allow-root &
	ABRMD_PID=$!

	set -e
	tpm2_dictionarylockout -c 2> /dev/null

	mount -t tmpfs none /tmp
	mount ${ROOT_BLK} /mnt
	cd /mnt/
	echo "backup filesystem to tmpfs..."
	tar -cf - . | pigz -c >/tmp/rootfs.tar.gz
	cd -
	umount /mnt

	echo "erase rootfs..."
	cat /dev/zero > ${ROOT_BLK} 2>/dev/null || true

	echo "encrypt rootfs..."
	echo -n ledge > pfile
	printf 'YES\n' | cryptsetup --type luks --cipher aes-xts-plain --hash sha256 --use-random --key-file pfile --uuid=${ROOT_UUID} luksFormat ${ROOT_BLK}

	printf 'ledge\ny\n' |  clevis luks bind -d ${ROOT_BLK} tpm2 '{"pcr_ids":"7"}' -s 1
	#cryptsetup luksDump ${ROOT_BLK}

	clevis luks pass -d ${ROOT_BLK} -s 1| cryptsetup luksOpen --key-file - ${ROOT_BLK} rootfs

	echo "create filesystem and unpack files..."
	mkfs.ext4 /dev/mapper/rootfs
	mount /dev/mapper/rootfs /rootfs
	cd /rootfs
	unpigz -c /tmp/rootfs.tar.gz | tar xpf -
	cd -
	sync
	echo "init.cryptfs: root mounted to /rootfs"
}

mount_rootfs_from_cmdline () {
	uuid=$(echo $ARG_ROOT | sed s/UUID=//)
	ROOT_BLK=$(blkid | grep ${uuid} | cut -d":" -f 1)
	if [ -z "${ROOT_BLK}" ]; then
		echo "No blk dev matching root=UUID=${uuid} check your /proc/cmdline:"
		cat /proc/cmdline
		/sbin/halt
		exit 1
	fi
	mount ${ROOT_BLK} /rootfs
	return 0
}

update_parsec_config () {
    parsec_config="/rootfs/etc/parsec/config.toml"
    for frag in optee tpm ; do
        fragfile="/rootfs/etc/parsec/config-fragment-$frag.toml"
        [ ! -e "$fragfile" ] && continue
        append=1
        [ "$frag" = "tpm" -a ! -e /dev/tpm0 ] && append=""
        [ "$frag" = "optee" ] && {
            if [ -e /dev/tee0 ]; then
                echo "Adding user parsec to group teeclnt"
                /rootfs/usr/sbin/chroot /rootfs /usr/sbin/usermod -a -G teeclnt parsec
            else
                append=""
            fi
        }
        [ "$append" ] && {
            echo "Appending $fragfile to $parsec_config"
            echo >>$parsec_config
            echo '# Added by init.ledge' >>$parsec_config
            cat $fragfile >>$parsec_config
        }
        echo "Removing $fragfile"
        rm -f $fragfile
    done
}

# For systems which do not have TPM device do mount non ecrypted rootfs
if [ ! -e /dev/tpm0 ]; then
	mount_rootfs_from_cmdline
	echo "/dev/tpm0 not found: using non encrypted rootfs"
	update_parsec_config
	exit 0
fi

# Search for block device matching ROOT_UUID and mount it
for d in /sys/class/block/*; do
	dev="/dev/$(basename $d)"
	uuid=$(cryptsetup luksUUID $dev)
	if [ -z "$uuid" ]; then
		continue
	fi
	if [ "$uuid" = "${ROOT_UUID}" ]; then
		clevis luks pass -d $dev -s 1| cryptsetup luksOpen --key-file - $dev rootfs
		mount /dev/mapper/rootfs /rootfs
		echo "init.cryptfs: root mounted to /rootfs"
		update_parsec_config
		exit 0
	fi
done

# No mounted luks, it looks like it's first boot.

# Configure Parsec providers on first boot
mount_rootfs_from_cmdline
update_parsec_config
umount /rootfs

# Then create luks partition for device specified in /proc/cmdline
cryptfs_create_enc_rootfs
